<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Love Story</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Parisienne&family=Cinzel+Decorative:wght@400;700&display=swap');

        :root {
            --primary-color: #ffc0cb; /* Soft Pink */
            --secondary-color: #add8e6; /* Light Blue */
            --accent-color: #ffd700; /* Gold */
            --text-color: #f0f8ff; /* Alice Blue (very light) */
            --bg-deep-space: #0a0a23; /* Deep Navy/Black */
            --bg-nebula-1: #4a0e4e; /* Deep Purple */
            --bg-nebula-2: #003366; /* Dark Blue */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Parisienne', cursive;
            background-color: var(--bg-deep-space);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        #starsCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .story-container {
            position: relative;
            z-index: 1;
            text-align: center;
            padding: 40px;
            max-width: 800px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(255, 192, 203, 0.3), 0 0 60px rgba(173, 216, 230, 0.3);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            opacity: 0;
            transform: translateY(50px);
            animation: fadeInStory 2s ease-out 1s forwards;
        }

        @keyframes fadeInStory {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-family: 'Cinzel Decorative', cursive;
            font-size: 3rem;
            color: var(--accent-color);
            margin-bottom: 20px;
            text-shadow: 0 0 10px var(--accent-color), 0 0 20px var(--accent-color);
            opacity: 0;
            animation: fadeInText 1.5s ease-out 2s forwards;
        }

        .verse {
            font-size: 1.8rem;
            line-height: 1.8;
            margin-bottom: 25px;
            opacity: 0;
            color: var(--text-color);
            text-shadow: 0 0 5px var(--primary-color);
        }

        /* Staggered animation for verses */
        .verse:nth-child(2) { animation: fadeInText 1.5s ease-out 2.5s forwards; }
        .verse:nth-child(3) { animation: fadeInText 1.5s ease-out 3.5s forwards; }
        .verse:nth-child(4) { animation: fadeInText 1.5s ease-out 4.5s forwards; }
        .verse:nth-child(5) { animation: fadeInText 1.5s ease-out 5.5s forwards; }
        .verse:nth-child(6) { animation: fadeInText 1.5s ease-out 6.5s forwards; }


        @keyframes fadeInText {
            to {
                opacity: 1;
            }
        }

        .souls-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 30px;
            position: relative;
            height: 100px; /* Ensure space for connection line */
        }

        .soul {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 50px;
            opacity: 0;
            box-shadow: 0 0 15px, 0 0 30px;
            animation: soulAppear 2s ease-out 7s forwards, soulPulse 3s infinite ease-in-out;
        }

        .soul.her {
            background-color: var(--primary-color);
            box-shadow: 0 0 15px var(--primary-color), 0 0 30px var(--primary-color);
            animation-delay: 7s, 7s; /* Stagger appearance slightly for effect */
        }

        .soul.him {
            background-color: var(--secondary-color);
            box-shadow: 0 0 15px var(--secondary-color), 0 0 30px var(--secondary-color);
            animation-delay: 7.5s, 7.5s;
        }
        
        @keyframes soulAppear {
            to {
                opacity: 0.8;
            }
        }

        @keyframes soulPulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        #connectionCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px; /* Width between souls approx */
            height: 20px; /* Height for the line */
            opacity: 0;
            animation: fadeInConnection 1s ease-out 8.5s forwards;
        }

        @keyframes fadeInConnection {
            to { opacity: 1; }
        }
        
        .final-message {
            margin-top: 40px;
            font-size: 1.5rem;
            color: var(--accent-color);
            opacity: 0;
            animation: fadeInText 2s ease-out 10s forwards;
             text-shadow: 0 0 8px var(--accent-color);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            h1 { font-size: 2.2rem; }
            .verse { font-size: 1.3rem; }
            .soul { width: 40px; height: 40px; margin: 0 30px; }
            #connectionCanvas { width: 120px; }
            .story-container { padding: 20px; }
        }
        @media (max-width: 480px) {
            h1 { font-size: 1.8rem; }
            .verse { font-size: 1.1rem; }
            .souls-container { flex-direction: column; height: auto; }
            .soul { margin: 20px 0; }
             #connectionCanvas { display: none; /* Simpler on very small screens or would need different logic */ }
            .final-message { font-size: 1.2rem; }
        }

    </style>
</head>
<body>
    <canvas id="starsCanvas"></canvas>
    
    <div class="story-container">
        <h1>Cosmic Serenade</h1>
        
        <p class="verse">In the velvet expanse, where galaxies dream,</p>
        <p class="verse">Two starlit souls, a luminous stream.</p>
        <p class="verse">One, a soft nebula, hues of gentle rose,</p>
        <p class="verse">The other, a comet, where azure light glows.</p>
        
        <div class="souls-container">
            <div class="soul her" id="soulHer"></div>
            <canvas id="connectionCanvas"></canvas>
            <div class="soul him" id="soulHim"></div>
        </div>
        
        <p class="verse">Across cosmic oceans, their essence entwined,</p>
        <p class="verse">A silent promise, for all of humankind.</p>

        <p class="final-message">... a universe born from a shared glance ...</p>
    </div>

    <script>
        // Starry background
        const starsCanvas = document.getElementById('starsCanvas');
        const starsCtx = starsCanvas.getContext('2d');
        let stars = [];
        const numStars = 300;

        function setCanvasSize() {
            starsCanvas.width = window.innerWidth;
            starsCanvas.height = window.innerHeight;
        }

        function initStars() {
            stars = [];
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * starsCanvas.width,
                    y: Math.random() * starsCanvas.height,
                    radius: Math.random() * 1.5 + 0.5, // Star size
                    alpha: Math.random() * 0.5 + 0.5,  // Star opacity
                    twinkleSpeed: Math.random() * 0.03 + 0.005, // Twinkle speed
                    color: `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.3})` // Vary initial brightness slightly
                });
            }
        }

        function drawStars() {
            starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);
            
            // Add a subtle nebula effect
            let gradient = starsCtx.createRadialGradient(
                starsCanvas.width / 2, starsCanvas.height / 2, 0,
                starsCanvas.width / 2, starsCanvas.height / 2, Math.max(starsCanvas.width, starsCanvas.height) / 1.5
            );
            gradient.addColorStop(0, 'rgba(10, 10, 35, 0.1)'); // Center of nebula (darker, transparent)
            gradient.addColorStop(0.3, 'rgba(74, 14, 78, 0.3)'); // Nebula color 1 (var(--bg-nebula-1) with alpha)
            gradient.addColorStop(0.6, 'rgba(0, 51, 102, 0.4)');  // Nebula color 2 (var(--bg-nebula-2) with alpha)
            gradient.addColorStop(1, 'rgba(10, 10, 35, 0.2)');   // Edge of nebula (darker, transparent)

            starsCtx.fillStyle = gradient;
            starsCtx.fillRect(0, 0, starsCanvas.width, starsCanvas.height);


            stars.forEach(star => {
                star.alpha += star.twinkleSpeed;
                if (star.alpha > 1 || star.alpha < 0.3) {
                    star.twinkleSpeed *= -1;
                }

                starsCtx.beginPath();
                starsCtx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                starsCtx.fillStyle = `rgba(255, 215, 0, ${star.alpha * 0.7})`; // Goldish twinkle
                starsCtx.shadowBlur = star.radius * 3;
                starsCtx.shadowColor = `rgba(255, 255, 255, ${star.alpha * 0.5})`;
                starsCtx.fill();

                // Fallback for simple stars if shadow too much
                // starsCtx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
                // starsCtx.fill();
            });
            starsCtx.shadowBlur = 0; // Reset shadow
        }

        function animateStars() {
            drawStars();
            requestAnimationFrame(animateStars);
        }

        window.addEventListener('resize', () => {
            setCanvasSize();
            initStars(); // Re-initialize stars for new size
        });

        setCanvasSize();
        initStars();
        animateStars();

        // Connection Line Animation
        const connectionCanvas = document.getElementById('connectionCanvas');
        const connectionCtx = connectionCanvas.getContext('2d');
        let animationProgress = 0;
        let animationStartTime;

        function drawConnectionLine(progress) {
            if (!connectionCanvas) return; // Guard for small screens where it might be hidden
            connectionCtx.clearRect(0, 0, connectionCanvas.width, connectionCanvas.height);
            
            const startX = 0;
            const endX = connectionCanvas.width;
            const y = connectionCanvas.height / 2;
            
            const currentX = startX + (endX - startX) * progress;

            connectionCtx.beginPath();
            connectionCtx.moveTo(startX, y);
            connectionCtx.lineTo(currentX, y);
            
            connectionCtx.lineWidth = 3;
            connectionCtx.strokeStyle = 'rgba(255, 215, 0, 0.8)'; // Gold
            connectionCtx.shadowColor = 'rgba(255, 215, 0, 1)';
            connectionCtx.shadowBlur = 10;
            connectionCtx.stroke();

            // Add a small particle traveling along the line
            if (progress > 0.1 && progress < 1) {
                connectionCtx.beginPath();
                connectionCtx.arc(currentX, y, 4, 0, Math.PI * 2);
                connectionCtx.fillStyle = 'rgba(255, 255, 255, 1)';
                connectionCtx.shadowColor = 'rgba(255, 255, 255, 1)';
                connectionCtx.shadowBlur = 8;
                connectionCtx.fill();
            }
            connectionCtx.shadowBlur = 0; // Reset
        }

        function animateConnection(timestamp) {
            if (!connectionCanvas) return;
            if (!animationStartTime) {
                animationStartTime = timestamp;
            }
            const elapsedTime = timestamp - animationStartTime;
            const duration = 2000; // 2 seconds for the line to draw

            animationProgress = Math.min(elapsedTime / duration, 1);
            drawConnectionLine(animationProgress);

            if (animationProgress < 1) {
                requestAnimationFrame(animateConnection);
            } else {
                // Once line is drawn, make it pulse subtly
                pulseConnection();
            }
        }
        
        let pulseDirection = 1;
        let pulseOpacity = 0.8;
        function pulseConnection() {
            if (!connectionCanvas) return;
            connectionCtx.clearRect(0, 0, connectionCanvas.width, connectionCanvas.height);
            
            pulseOpacity += 0.01 * pulseDirection;
            if (pulseOpacity > 1 || pulseOpacity < 0.6) {
                pulseDirection *= -1;
            }

            const startX = 0;
            const endX = connectionCanvas.width;
            const y = connectionCanvas.height / 2;

            connectionCtx.beginPath();
            connectionCtx.moveTo(startX, y);
            connectionCtx.lineTo(endX, y);
            
            connectionCtx.lineWidth = 3;
            connectionCtx.strokeStyle = `rgba(255, 215, 0, ${pulseOpacity})`;
            connectionCtx.shadowColor = `rgba(255, 215, 0, ${pulseOpacity})`;
            connectionCtx.shadowBlur = 10 + (pulseOpacity - 0.6) * 10; // More blur when brighter
            connectionCtx.stroke();
            connectionCtx.shadowBlur = 0;
            
            requestAnimationFrame(pulseConnection);
        }


        // Start connection animation after a delay (sync with CSS fadeInConnection)
        setTimeout(() => {
             if (connectionCanvas && getComputedStyle(connectionCanvas).display !== 'none') { // Check if it's visible
                requestAnimationFrame(animateConnection);
             }
        }, 8500); // Must match CSS animation delay for #connectionCanvas

    </script>
</body>
</html>