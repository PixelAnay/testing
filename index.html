<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ephemeral Echoes</title>
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden; /* No scrollbars for this one, full screen experience */
            background-color: #030308; /* Very dark, almost black blue */
            font-family: 'Times New Roman', Times, serif; /* Classic, elegant */
        }

        #mainCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .text-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            text-align: center;
            color: rgba(220, 220, 255, 0.8); /* Soft ethereal text color */
            pointer-events: none; /* Allow canvas interaction */
        }

        .text-overlay p {
            font-size: 1.8rem;
            line-height: 1.6;
            opacity: 0;
            transition: opacity 2.5s ease-in-out;
            text-shadow: 0 0 10px rgba(180, 180, 255, 0.5), 0 0 20px rgba(150, 150, 220, 0.3);
            margin-bottom: 15px;
        }

        .text-overlay p.visible {
            opacity: 1;
        }

        .text-overlay p.small {
            font-size: 1rem;
            font-style: italic;
            color: rgba(200, 200, 230, 0.6);
        }

        /* For subtle cues or instructions if needed later */
        .instruction {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(200, 200, 255, 0.4);
            font-size: 0.9rem;
            z-index: 3;
            opacity: 0;
            animation: fadeInOutHint 10s ease-in-out 5s forwards;
        }
        
        @keyframes fadeInOutHint {
            0%, 100% { opacity: 0; }
            10%, 40% { opacity: 1; }
            50% { opacity: 0; } /* Keep it faded out after one cycle or make it loop */
        }

        /* Loading screen (optional but good for single file with lots of JS) */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #030308;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            font-size: 1.5rem;
            transition: opacity 1s ease-out;
        }
    </style>
</head>
<body>
    <div id="loading-screen">Loading Ephemeral Echoes...</div>

    <canvas id="mainCanvas"></canvas>
    <div class="text-overlay" id="textContainer">
        <!-- Text will be injected here by JavaScript -->
    </div>

    <div class="instruction" id="mouseInstruction">(Move your mouse)</div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const textContainer = document.getElementById('textContainer');
        const loadingScreen = document.getElementById('loading-screen');
        const mouseInstruction = document.getElementById('mouseInstruction');

        let width, height;
        let particles = [];
        let attractors = [];
        let mouse = { x: null, y: null, active: false };
        let hue = 0; // For evolving colors
        let animationFrameId;
        let currentStage = 0;
        let stageTimer = 0;
        const stageDuration = 10 * 1000; // 10 seconds per stage, adjust as needed

        // --- Narrative Stages ---
        const narrative = [
            { text: ["In the quiet hum of becoming...", "two solitary whispers."], duration: 12000 },
            { text: ["One, a gentle warmth,", "a soft bloom in the velvet dark."], colors: { base: 20, range: 20 }, particleType: 'bloom' }, // Warmer hues (reds, oranges)
            { text: ["The other, a distant shimmer,", "a cool gleam in the infinite expanse."], colors: { base: 200, range: 30 }, particleType: 'shimmer' }, // Cooler hues (blues, cyans)
            { text: ["A faint stirring...", "an unseen resonance across the void."], colors: { base: 120, range: 60}, particleType: 'mixed' }, // Greens, yellows, broader spectrum
            { text: ["Threads of light begin to weave,", "pulled by a silent call."], colors: { base: 280, range: 40 }, particleType: 'tendrils' }, // Purples, magentas
            { text: ["Two streams converge,", "a dance of intertwined echoes."], colors: { base: 0, range: 360 }, particleType: 'intertwined' }, // Full spectrum, very vibrant
            { text: ["A new luminescence born,", "their shared breath, a vibrant star."], colors: { base: 60, range: 60 }, particleType: 'nova' }, // Golds, whites, bright
            { text: ["And in that silent song,", "an eternal echo remains."], colors: { base: 240, range: 30}, particleType: 'legacy', duration: 15000 } // Deep blues, silvers, sustained
        ];

        // --- Particle Class ---
        class Particle {
            constructor(x, y, type = 'default') {
                this.x = x;
                this.y = y;
                this.originX = x;
                this.originY = y;
                this.size = Math.random() * 3 + 1;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.baseHue = narrative[currentStage].colors ? narrative[currentStage].colors.base : hue;
                this.hueRange = narrative[currentStage].colors ? narrative[currentStage].colors.range : 60;
                this.colorHue = this.baseHue + (Math.random() * this.hueRange - this.hueRange / 2);
                this.life = Math.random() * 100 + 150; // Lifespan
                this.initialLife = this.life;
                this.type = type;
                this.history = []; // For trails
                this.maxHistory = Math.floor(Math.random() * 10 + 5);
            }

            update() {
                // Attraction/Repulsion (simple for now)
                attractors.forEach(attractor => {
                    const dx = attractor.x - this.x;
                    const dy = attractor.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < attractor.radius) {
                        const force = (attractor.radius - dist) / attractor.radius * attractor.strength;
                        this.vx += (dx / dist) * force * 0.05; // Adjusted force application
                        this.vy += (dy / dist) * force * 0.05;
                    }
                });

                // Mouse interaction
                if (mouse.active && mouse.x != null) {
                    const mdx = mouse.x - this.x;
                    const mdy = mouse.y - this.y;
                    const mDist = Math.sqrt(mdx * mdx + mdy * mdy);
                    if (mDist < 100) { // Mouse influence radius
                        const mForce = (100 - mDist) / 100 * 0.5; // Repulsive force
                        this.vx -= (mdx / mDist) * mForce;
                        this.vy -= (mdy / mDist) * mForce;
                    }
                }

                this.x += this.vx;
                this.y += this.vy;

                // Friction/damping
                this.vx *= 0.97;
                this.vy *= 0.97;

                // Keep within bounds or fade out
                if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
                    this.life -= 5; // Fade faster if out of bounds
                }
                
                this.life--;

                // Update history for trails
                this.history.push({x: this.x, y: this.y});
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                }
            }

            draw() {
                const alpha = Math.max(0, (this.life / this.initialLife) * 0.8);
                
                ctx.beginPath();
                // Draw trail
                if (this.history.length > 1) {
                    ctx.moveTo(this.history[0].x, this.history[0].y);
                    for (let i = 1; i < this.history.length; i++) {
                         const histAlpha = alpha * (i / this.history.length);
                         ctx.strokeStyle = `hsla(${this.colorHue}, 80%, ${60 + (i/this.history.length)*20}%, ${histAlpha * 0.5})`;
                         ctx.lineWidth = this.size * (i / this.history.length) * 0.8;
                         ctx.lineTo(this.history[i].x, this.history[i].y);
                    }
                    ctx.stroke();
                }

                // Draw particle head
                ctx.fillStyle = `hsla(${this.colorHue}, 90%, 70%, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();

                // Subtle glow
                ctx.shadowBlur = this.size * 2;
                ctx.shadowColor = `hsla(${this.colorHue}, 100%, 60%, 0.5)`;
                ctx.fill(); // Fill again to apply shadow
                ctx.shadowBlur = 0; // Reset shadow
            }
        }
        
        // --- Attractor Class ---
        class Attractor {
            constructor(x, y, radius, strength) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.strength = strength; // Positive for attraction, negative for repulsion
            }
        }

        // --- Setup ---
        function setup() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            particles = [];
            attractors = [];
            currentStage = 0;
            stageTimer = 0;
            updateNarrative();
            createInitialAttractors();
            mouse.active = false; // Mouse inactive initially
            setTimeout(() => mouse.active = true, 3000); // Activate mouse after a delay
        }

        function createInitialAttractors() {
            attractors = []; // Clear previous
            const particleType = narrative[currentStage].particleType;

            if (particleType === 'bloom') {
                attractors.push(new Attractor(width * 0.3, height * 0.5, Math.min(width, height) * 0.2, 0.2));
            } else if (particleType === 'shimmer') {
                attractors.push(new Attractor(width * 0.7, height * 0.5, Math.min(width, height) * 0.2, 0.2));
            } else if (particleType === 'tendrils' || particleType === 'intertwined') {
                attractors.push(new Attractor(width * 0.4, height * 0.5, Math.min(width, height) * 0.15, 0.3));
                attractors.push(new Attractor(width * 0.6, height * 0.5, Math.min(width, height) * 0.15, 0.3));
            } else if (particleType === 'nova' || particleType === 'legacy') {
                 attractors.push(new Attractor(width * 0.5, height * 0.5, Math.min(width, height) * 0.25, 0.1)); // Central, softer pull
            }
            // For 'mixed' or default, fewer or no specific attractors, more free-floating
        }

        // --- Narrative Text Update ---
        function updateNarrative() {
            textContainer.innerHTML = '';
            if (narrative[currentStage]) {
                narrative[currentStage].text.forEach((line, index) => {
                    const p = document.createElement('p');
                    p.textContent = line;
                    if (index === narrative[currentStage].text.length -1 && narrative[currentStage].text.length > 1) {
                         p.classList.add('small'); // Last line smaller if multiple lines
                    }
                    textContainer.appendChild(p);
                    // Staggered fade-in for text lines
                    setTimeout(() => p.classList.add('visible'), index * 1000 + 500);
                });
            }
            createInitialAttractors(); // Recreate attractors based on new stage
        }
        
        // --- Particle Spawning ---
        function spawnParticles() {
            const numToSpawn = 2; // Spawn a few particles per frame
            const particleType = narrative[currentStage].particleType;

            for (let i = 0; i < numToSpawn; i++) {
                if (particles.length > 300) continue; // Max particles

                let x, y;
                if (particleType === 'bloom') {
                    x = width * (0.2 + Math.random() * 0.2); // Leftish side
                    y = height * (0.4 + Math.random() * 0.2);
                } else if (particleType === 'shimmer') {
                    x = width * (0.6 + Math.random() * 0.2); // Rightish side
                    y = height * (0.4 + Math.random() * 0.2);
                } else if (particleType === 'tendrils') {
                    // Spawn from two points moving towards center
                    x = (Math.random() < 0.5) ? width * (0.1 + Math.random() * 0.1) : width * (0.8 + Math.random() * 0.1);
                    y = height * (0.3 + Math.random() * 0.4);
                } else if (particleType === 'intertwined' || particleType === 'nova' || particleType === 'legacy') {
                    x = width * 0.5 + (Math.random() - 0.5) * width * 0.1; // Centerish
                    y = height * 0.5 + (Math.random() - 0.5) * height * 0.1;
                } else { // Default / mixed
                    x = Math.random() * width;
                    y = Math.random() * height;
                }
                particles.push(new Particle(x, y, particleType));
            }
        }

        // --- Animation Loop ---
        function animate(timestamp) {
            // Stage progression
            stageTimer += timestamp - (lastTimestamp || timestamp); // Add delta time
            lastTimestamp = timestamp;

            const currentStageDuration = (narrative[currentStage] && narrative[currentStage].duration) || stageDuration;

            if (stageTimer >= currentStageDuration) {
                currentStage++;
                stageTimer = 0;
                if (currentStage >= narrative.length) {
                    currentStage = 0; // Loop narrative or stop
                    // Or perhaps transition to a final, unending state:
                    // currentStage = narrative.length - 1; 
                    // narrative[currentStage].duration = Infinity;
                }
                updateNarrative();
            }

            // Clear canvas with a fading trail effect
            ctx.fillStyle = 'rgba(3, 3, 8, 0.1)'; // Very dark blue, low alpha for trails
            ctx.fillRect(0, 0, width, height);

            spawnParticles();

            particles.forEach((p, index) => {
                p.update();
                p.draw();
                if (p.life <= 0) {
                    particles.splice(index, 1);
                }
            });

            // Evolve global hue slowly for background subtle shifts (if not overridden by stage)
            if (!narrative[currentStage].colors) {
                hue = (hue + 0.1) % 360;
            }
            
            animationFrameId = requestAnimationFrame(animate);
        }
        let lastTimestamp = 0;

        // --- Event Listeners ---
        window.addEventListener('resize', () => {
            // Debounce resize
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(() => {
                cancelAnimationFrame(animationFrameId); // Stop animation
                setup(); // Re-initialize
                animationFrameId = requestAnimationFrame(animate); // Restart animation
            }, 250);
        });

        window.addEventListener('mousemove', (e) => {
            if (mouse.active) {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
                if (mouseInstruction.style.opacity !== "0") { // Fade out instruction on first move
                     mouseInstruction.style.opacity = "0";
                     mouseInstruction.style.animation = "none"; // Stop animation if it was running
                }
            }
        });
        window.addEventListener('mouseout', () => {
            if (mouse.active) {
                mouse.x = null;
                mouse.y = null;
            }
        });
        
        // --- Start ---
        window.onload = () => {
            setup();
            animationFrameId = requestAnimationFrame(animate);
            // Fade out loading screen
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                setTimeout(() => loadingScreen.style.display = 'none', 1000);
            }, 500); // Give a little time for initial setup
        };

    </script>
</body>
</html>